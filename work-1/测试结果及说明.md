# 测试结果及说明

- learing-rate 统一取值为：==**α = 0.1**==

## 标量 method-1.py

- ##### 一共feture_cnt （13+1） * case_cnt（400） 次 标量乘法

<img src=".\img\image-20211118164209900.png" alt="image-20211118164209900" style="zoom: 67%;" />

## 向量 method-2.py

- ##### 一共 case_cnt（400） 次向量乘法

<img src=".\img\image-20211118164617668.png" alt="image-20211118164617668" style="zoom: 50%;" />

## 矩阵 method-3.py

- ##### 一次矩阵乘法

<img src=".\img\image-20211118164916621.png" alt="image-20211118164916621" style="zoom: 50%;" />





## 结果分析

- 采用标量的方式进行梯度下降法求解，发现运行时间为**272.2490813 s**

<img src=".\img\image-20211118165049876.png" alt="image-20211118165049876" style="zoom:50%;" />

- 采用向量的方式进行梯度下降法求解，发现运行时间为**19.7579552 s**

<img src=".\img\image-20211118164759853.png" alt="image-20211118164759853" style="zoom:50%;" />

- 采用矩阵的方式进行梯度下降法求解，发现运行时间**3.284343 s**

<img src=".\img\image-20211118165300549.png" alt="image-20211118165300549" style="zoom:50%;" />

**时间比较：**

- 采用**矩阵**的方式，运行速度更快，效率更高
- 耗费时间：**采用标量的形式＞采用向量的形式＞采用矩阵的形式** 

**编程量比较：**

- 三者的编程量的区别主要在于更新 θ 的代码，采用**矩阵**的方式 实际更新θ的代码只需要一行就完成，

- 代码量：**采用标量的形式＞采用向量的形式＞采用矩阵的形式** 



## 附录：

最后用测试集进行测试，结果如下：

<img src=".\img\image-20211118165435752.png" alt="image-20211118165435752" style="zoom: 67%;" />